<h1>About the program</h1>

<p>This program reads a certain description of an undirected graph and
determines the number of connected components of it.</p>

<h2>About the description of the graph</h2>

<p>The graph shall be read from a file. The file describes
the graph by way of specifying the number of nodes, the
number of edges and a description of what nodes
each edge connects.</p>

<h3>Syntax</h3>

<p>The input file consists only of a series of arbitrarily space-
separated integer constants written in plain ASCII, and
consequently, also readable as an UTF-8 plain text file.</p>

<p>The first two integers shall be the number of nodes (n), and the
number of edges (m), respectively.</p>

<p>Given this, the set of nodes is assumed to be {1, 2, &hellip; n}, and
each node will be referred simply by its number.</p>

<p>Then comes &ldquo;m&rdquo; pairs of integers &ldquo;u&rdquo; and &ldquo;v&rdquo; each giving the
existence of a bidirectional edge between nodes &ldquo;u&rdquo; and &ldquo;v&rdquo;.</p>

<h2>The command line interface</h2>

<p>As a binary, our program shall receive one and only one command line argument, and this will
be interpreted as the file name for the input file described in #/about/interface/syntax.</p>

<p>If the input file doesn&rsquo;t comply with the #/about/interface/syntax our program will fail silently.</p>

<h1>The program</h1>

<p>As this program will be considerably small, it will consist of a single source file
in which we will put all of our code.</p>

<h2>Source file &ldquo;source/app.d&rdquo;</h2>

<p>The one and only sourcefile. Will contain everything.
The structure of this file will be typical.</p>

<h2>&lt; source/app.d > +=</h2>

<pre><code>&gt; Import declarations
&gt; Global variable definitions
&gt; Function definitions
</code></pre>

<h2>&lt; Import declarations > =</h2>

<p>In this fragment will be included the import declarations that we see
fit.</p>

<h2>&lt; Global variable definitions > =</h2>

<p>In this fragment we will be creating and initializing global variables
as we require them.</p>

<h2>&lt; Function definitions > =</h2>

<p>In this fragment we will be inserting our function definitions.</p>

<p>As per the rules of the D programming language, the order in which we insert new fragments
into the three previous fragments won&rsquo;t affect the final result.</p>

<h2>The main function</h2>

<p>The main function will be the entry point to our program. This is the starting point of execution.
The structure of this function will be typical of a D program.</p>

<h3>&lt; Function definitions > +=</h3>

<pre><code>void main(string[] args)
{
  &gt; Local variables definitions
  &gt; Main process
}
</code></pre>

<h3>&lt; Local variables definitions > =</h3>

<p>In this fragment we will be inserting the local variables we require.</p>

<h3>&lt; Main process > =</h3>

<p>In this fragment we will input how our main function does its processing.</p>

<p>Where <code>args</code> is an array of strings that contains the arguments we received from the user. The first argument is always the name of the binary,
the rest are given by the user.</p>

<h3>The process</h3>

<h4>&lt; Main process > +=</h4>

<pre><code>&gt; Commandline arguments validation
&gt; Read the input
&gt; Compute the answer
&gt; Write the answer
</code></pre>

<h4>&lt; Commandline arguments validation > =</h4>

<p>As it is normal in a program with command-line interface, our
first job shall be to validate the arguments that we are given.</p>

<h4>&lt; Read the input > =</h4>

<p>Given that we have a valid argument giving us the input file name.
We will try to open the given file and get it&rsquo;s data (ala Succ).
This fragment&rsquo;s job will imply verifying the existence and syntax of
the given file.</p>

<h4>&lt; Compute the answer > =</h4>

<p>With the information about the graph we will now be ready to compute the
number of connected components of it.</p>

<h4>&lt; Write the answer > =</h4>

<p>Given the answer obtained in the previous fragment. We will present it to
the user through stdout.
\paragraph{Commandline arguments validation}
To do this, it is enough to verify that we have been given one and only one user-defined commandline argument.
The first given argument in &ldquo;args&rdquo; is always the name of the binary, so we need to verify that the args array
is of size 2 exactly.</p>

<h4>&lt; Commandline arguments validation > +=</h4>

<pre><code>if (args.length != 2)
{
  import std.stdio: stderr;
  stderr.writeln("Expected an only argument giving an input file");
  return;
}
</code></pre>

<p>Before reading the input we must know how</p>
